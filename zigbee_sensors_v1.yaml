
# Surveillance enrichie des devices Zigbee sur batterie
# Ce capteur centralise les données MQTT de Z2M et les croise avec les états Home Assistant
# Dossier : monitoring-zigbee

- trigger:
    - platform: mqtt
      topic: zigbee2mqtt02/bridge/devices
    - platform: state
      entity_id: button.actualiser_monitoring_zigbee
  sensor:
    - name: "Z2M Battery Devices"
      unique_id: z2m_battery_devices
      state: >
        {# FIX V3: Triple protection #}
        {% if trigger.platform == 'mqtt' and trigger.payload is defined %}
          {% set devices = trigger.payload | from_json %}
        {% elif this.attributes.raw_devices is defined and this.attributes.raw_devices is not none %}
          {% set devices = this.attributes.raw_devices %}
        {% else %}
          {% set devices = [] %}
        {% endif %}
        {% if devices | length > 0 %}
          {{ devices | selectattr('power_source', 'defined') | selectattr('power_source', 'eq', 'Battery') | list | length }}
        {% else %}
          {{ this.state | default(0) }}
        {% endif %}
      icon: mdi:battery-check
      attributes:
        last_check: "{{ now().isoformat() }}"
        
        # DEBUG: Pour diagnostiquer le problème du bouton
        _debug_trigger: >
          {
            "platform": "{{ trigger.platform }}",
            "has_payload": {{ 'true' if trigger.payload is defined else 'false' }},
            "has_raw_devices": {{ 'true' if this.attributes.raw_devices is defined else 'false' }},
            "raw_devices_is_none": {{ 'true' if this.attributes.raw_devices is none else 'false' }},
            "raw_devices_length": {{ this.attributes.raw_devices | length if this.attributes.raw_devices is not none else -1 }}
          }
        
        # Stockage de la liste brute pour permettre le refresh manuel sans MQTT
        # FIX V3: Triple protection + ne rien faire si pas de données MQTT sur trigger state
        raw_devices: >
          {% if trigger.platform == 'mqtt' and trigger.payload is defined %}
            {{ trigger.payload | from_json }}
          {% elif this.attributes.raw_devices is defined and this.attributes.raw_devices is not none %}
            {{ this.attributes.raw_devices }}
          {% else %}
            []
          {% endif %}
        
        devices: >
          {# FIX V3: Triple protection #}
          {% if trigger.platform == 'mqtt' and trigger.payload is defined %}
            {% set raw = trigger.payload | from_json %}
          {% elif this.attributes.raw_devices is defined and this.attributes.raw_devices is not none %}
            {% set raw = this.attributes.raw_devices %}
          {% else %}
            {% set raw = [] %}
          {% endif %}
          {% set devices = raw | selectattr('power_source', 'defined') | selectattr('power_source', 'eq', 'Battery') | list %}
          {% set enriched = namespace(list=[]) %}
          
          {# 2. Boucle pour enrichir chaque appareil avec des données temps réel de Home Assistant #}
          {% for d in devices %}
            {# Extraction de la date de maintenance de la description Z2M (ex: "pile 01/01/2024") #}
            {% set desc = d.description | default('') %}
            {% set m_date = desc if ('pile' in desc or '/' in desc) else 'jamais' %}
            
            {# Préparation du nom pour la recherche d'entité (en minuscule pour éviter les fautes de frappe) #}
            {% set search_name = d.friendly_name | lower %}
            
            {# STRATÉGIE DE RECHERCHE D'ENTITÉ (MATCHING) AMÉLIORÉE #}
            
            {# Essai 1 : Priorité absolue si l'entité finit par "_battery" (standard Z2M) #}
            {% set batt_entity = states.sensor 
              | selectattr('attributes.device_class', 'defined') 
              | selectattr('attributes.device_class', 'eq', 'battery')
              | selectattr('entity_id', 'search', search_name ~ '_battery$')
              | first | default(none) %}

            {# Essai 2 : Si échec, recherche large dans l'ID #}
            {% if batt_entity is none %}
              {% set batt_entity = states.sensor 
                | selectattr('attributes.device_class', 'defined') 
                | selectattr('attributes.device_class', 'eq', 'battery')
                | selectattr('entity_id', 'search', search_name)
                | first | default(none) %}
            {% endif %}
            
            {# Essai 3 : Si échec, recherche par le friendly_name Home Assistant #}
            {% if batt_entity is none %}
              {% set batt_entity = states.sensor 
                | selectattr('attributes.device_class', 'defined') 
                | selectattr('attributes.device_class', 'eq', 'battery')
                | selectattr('attributes.friendly_name', 'defined')
                | selectattr('attributes.friendly_name', 'search', d.friendly_name)
                | first | default(none) %}
            {% endif %}

            {# Essai 4 : Recherche de n'importe quelle entité liée à ce nom pour le statut Online/Offline #}
            {% if batt_entity is none %}
               {% set any_entity = states.sensor 
                 | selectattr('entity_id', 'search', search_name)
                 | first | default(states.binary_sensor | selectattr('entity_id', 'search', search_name) | first | default(none)) %}
            {% else %}
               {% set any_entity = batt_entity %}
            {% endif %}
            
            {# 3. Création de l'objet final pour cet appareil #}
            {% set enriched.list = enriched.list + [{
              'name': d.friendly_name,
              'status': 'offline' if (any_entity is none or any_entity.state == 'unavailable') else 'online',
              'battery': batt_entity.state if (batt_entity is not none and batt_entity.state | is_number) else '?',
              'maintenance': m_date,
              'entity_debug': any_entity.entity_id if any_entity is not none else 'non trouvé'
            }] %}
          {% endfor %}
          
          {# Renvoyer la liste triée par nom pour l'affichage #}
          {{ enriched.list | sort(attribute='name') }}

- sensor:
    - name: "Zigbee Battery Alerts"
      unique_id: zigbee_battery_alerts
      state: >
        {# Ce capteur compte les devices nécessitant une attention (Offline, Pile < 15% ou Inconnue) #}
        {% set devices = state_attr('sensor.z2m_battery_devices', 'devices') | default([]) %}
        {% set alerts = namespace(count=0) %}
        {% for d in devices %}
          {% set battery_val = d.battery | float(-1) if d.battery != '?' else -1 %}
          {% if d.status == 'offline' or d.battery == '?' or (battery_val != -1 and battery_val < 15) %}
            {% set alerts.count = alerts.count + 1 %}
          {% endif %}
        {% endfor %}
        {{ alerts.count }}
      icon: >
        {{ 'mdi:alert-circle' if states('sensor.zigbee_battery_alerts') | int(0) > 0 else 'mdi:check-circle' }}
      attributes:
        # Liste filtrée pour l'automation et le dashboard
        alert_devices: >
          {% set devices = state_attr('sensor.z2m_battery_devices', 'devices') | default([]) %}
          {% set list = namespace(items=[]) %}
          {% for d in devices %}
            {% set battery_val = d.battery | float(-1) if d.battery != '?' else -1 %}
            {% if d.status == 'offline' or d.battery == '?' or (battery_val != -1 and battery_val < 15) %}
              {% set list.items = list.items + [d] %}
            {% endif %}
          {% endfor %}
          {{ list.items }}

- button:
  - name: "Actualiser Monitoring Zigbee"
    unique_id: force_zigbee_refresh_btn
    icon: mdi:refresh
    press:
      - delay: "00:00:01"